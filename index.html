<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AWS Solutions Architect Exam Practice</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #232526 0%, #414345 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 14px;
        }

        .content {
            padding: 30px;
        }

        .question-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 30px;
            border-left: 5px solid #667eea;
            transition: transform 0.2s;
        }

        .question-card:hover {
            transform: translateX(5px);
        }

        .question-header {
            display: flex;
            align-items: start;
            margin-bottom: 20px;
        }

        .question-number {
            background: #667eea;
            color: white;
            padding: 8px 15px;
            border-radius: 50px;
            font-weight: bold;
            margin-right: 15px;
            flex-shrink: 0;
        }

        .question-text {
            font-size: 16px;
            line-height: 1.6;
            color: #2d3748;
            font-weight: 500;
        }

        .options {
            margin: 20px 0;
        }

        .option {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: start;
        }

        .option:hover {
            border-color: #667eea;
            background: #f7fafc;
        }

        .option input[type="checkbox"] {
            margin-right: 12px;
            margin-top: 3px;
            cursor: pointer;
            width: 18px;
            height: 18px;
            flex-shrink: 0;
        }

        .option-text {
            flex: 1;
            line-height: 1.5;
            color: #4a5568;
        }

        .answer-section {
            background: #fff5f5;
            border: 2px solid #feb2b2;
            border-radius: 8px;
            padding: 20px;
            margin-top: 15px;
            display: none;
        }

        .answer-section.show {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .correct-answer {
            font-weight: bold;
            color: #22543d;
            margin-bottom: 15px;
            padding: 10px;
            background: #c6f6d5;
            border-radius: 5px;
        }

        .explanation {
            color: #2d3748;
            line-height: 1.7;
            white-space: pre-line;
        }

        .show-answers-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            display: block;
            margin: 30px auto;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
            transition: all 0.3s;
        }

        .show-answers-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 35px rgba(102, 126, 234, 0.5);
        }

        .show-answers-btn:active {
            transform: translateY(0);
        }

        @media (max-width: 768px) {
            .container {
                border-radius: 0;
            }

            .content {
                padding: 20px;
            }

            .header h1 {
                font-size: 22px;
            }

            .question-card {
                padding: 20px;
            }

            .question-header {
                flex-direction: column;
            }

            .question-number {
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>AWS Solutions Architect Practice Exam</h1>
            <p>Select your answers and click "Show Answers" to see results</p>
        </div>

        <div class="content" id="questionsContainer"></div>

        <button class="show-answers-btn" onclick="showAllAnswers()">Show Answers & Explanations</button>
    </div>

    <script>
        const questions = [
            {
                number: 211,
                text: "A company has 4,000 virtual machines running in a VMware vSphere/ESXi environment. The company wants to migrate to AWS, but they have: No CMDB, No performance monitoring tools, No detailed inventory, No visibility into utilization or idle resources. The company wants to estimate migration cost, identify underutilized VMs, and build an AWS migration plan with the least operational overhead. Which solution should a solutions architect recommend?",
                options: [
                    "Deploy the AWS Application Migration Service (MGN) agent on all VMs. Use Amazon Athena to analyze server performance. Export idle servers manually and exclude them from migration.",
                    "Use VMware tools to export VM data to CSV. Import the CSV into AWS Migration Hub. Perform manual analysis to identify underutilized workloads.",
                    "Deploy the agentless Migration Evaluator collector on the ESXi hosts. Allow it to gather performance and utilization data automatically. Review the reports in Migration Evaluator and export migration recommendations to AWS Migration Hub.",
                    "Use AWS Systems Manager to install CloudWatch agent on all VMs. Send performance metrics to CloudWatch. Build a server utilization dashboard in QuickSight and manually identify idle servers."
                ],
                correct: "C",
                explanation: "Migration Evaluator (formerly TSO Logic) provides: Agentless data collection from the ESXi hypervisor, Automatic performance & utilization analysis, Right-sizing recommendations, Cost modeling for migration, Import directly into AWS Migration Hub, Zero need to touch each VM individually."
            },
            {
                number: 212,
                text: "A company runs a microservice as an AWS Lambda function. The microservice writes data to an on-premises SQL database that supports a limited number of concurrent connections. When too many Lambda invocations occur, the database crashes and causes downtime. The company has an AWS Direct Connect link and wants to protect the database from crashing. Which solution will meet these requirements?",
                options: [
                    "Write the data to an Amazon SQS queue. Configure the Lambda function to read from the queue and write to the existing database. Set a reserved concurrency limit on the Lambda function that is less than the number of connections the database supports.",
                    "Create a new Amazon Aurora Serverless DB cluster. Use AWS DataSync to migrate the data from the existing database to Aurora Serverless. Reconfigure the Lambda function to write to Aurora.",
                    "Create an Amazon RDS Proxy DB instance. Attach the RDS Proxy to the Amazon RDS DB instance. Reconfigure the Lambda function to write to the RDS Proxy.",
                    "Write the data to an Amazon SNS topic. Invoke the Lambda function to write to the database when the topic receives messages. Configure provisioned concurrency for the Lambda to match the database's supported connections."
                ],
                correct: "A",
                explanation: "Option A uses Amazon SQS as a buffer and Lambda reserved concurrency to throttle write operations. SQS stores incoming write requests and smooths traffic spikes. Reserved Concurrency on Lambda limits concurrent executions to a safe number (e.g., if DB supports 5 connections, set concurrency = 5). This ensures the DB never receives more writes than it can handle, with no database migration needed."
            },
            {
                number: 213,
                text: "A company uses a Grafana data visualization solution that runs on a single Amazon EC2 instance to monitor the health of the company's AWS workloads. The company has put extensive effort into building dashboards that must be preserved. Requirements: Dashboards must be highly available, Downtime cannot exceed 10 minutes, Company wants minimal ongoing maintenance, Grafana dashboards must be retained. Which solution meets these requirements with the LEAST operational overhead?",
                options: [
                    "Migrate to Amazon CloudWatch Dashboards. Recreate dashboards to match existing Grafana dashboards. Use automatic dashboards where possible.",
                    "Create an Amazon Managed Grafana workspace. Configure a new Amazon CloudWatch data source. Export dashboards from the existing Grafana instance. Import them into the Managed Grafana workspace.",
                    "Create an AMI with Grafana pre-installed. Store dashboards in Amazon EFS. Use an Auto Scaling group with ALB across two Availability Zones.",
                    "Configure AWS Backup to back up the EC2 instance hourly. Restore the EC2 from the newest snapshot in another Availability Zone when required."
                ],
                correct: "B",
                explanation: "Managed Grafana = No servers to maintain (Fully managed by AWS, Automatic scaling and high availability, No patching, no EC2, no ALB, no Auto Scaling groups). Dashboards can be imported - Existing Grafana JSON dashboards can be exported from EC2 Grafana and imported directly into Managed Grafana. Downtime < 10 min - Cutover can happen quickly. Meets all requirements: Highly available, Preserves dashboards, Minimal maintenance, No infrastructure to maintain, AWS-native integrations."
            },
            {
                number: 214,
                text: "A company needs to migrate its customer transactions database from on premises to AWS. The database resides on an Oracle DB instance running on a Linux server. A new security requirement states that the company must rotate the database password every year. Which solution will meet these requirements with the LEAST operational overhead?",
                options: [
                    "Convert the database to Amazon DynamoDB using AWS Schema Conversion Tool (SCT). Store the password in AWS Systems Manager Parameter Store. Use an Amazon CloudWatch alarm to invoke a Lambda function for yearly password rotation.",
                    "Migrate the database to Amazon RDS for Oracle. Store the password in AWS Secrets Manager. Turn on automatic rotation. Configure a yearly rotation schedule.",
                    "Migrate the database to an Amazon EC2 instance. Use Systems Manager Parameter Store to store and rotate the connection string using Lambda on a yearly schedule.",
                    "Migrate the database to Amazon Neptune using AWS SCT. Configure CloudWatch to invoke a Lambda function for yearly password rotation."
                ],
                correct: "B",
                explanation: "Amazon RDS for Oracle with AWS Secrets Manager provides fully automated password rotation with minimal operational overhead. Secrets Manager has built-in automatic rotation capabilities and integrates seamlessly with RDS for Oracle."
            },
            {
                number: 215,
                text: "A solutions architect is designing an AWS account structure for a company that consists of multiple teams. All the teams will work in the same AWS Region. The company needs a VPC that is connected to the on-premises network. The company expects less than 50 Mbps of total traffic to and from the on-premises network. Which combination of steps will meet these requirements MOST cost-effectively? (Choose two.)",
                options: [
                    "Create an AWS CloudFormation template that provisions a VPC and the required subnets. Deploy the template to each AWS account.",
                    "Create an AWS CloudFormation template that provisions a VPC and the required subnets. Deploy the template to a shared services account. Share the subnets by using AWS Resource Access Manager.",
                    "Use AWS Transit Gateway along with an AWS Site-to-Site VPN for connectivity to the on-premises network. Share the transit gateway by using AWS Resource Access Manager.",
                    "Use AWS Site-to-Site VPN for connectivity to the on-premises network.",
                    "Use AWS Direct Connect for connectivity to the on-premises network."
                ],
                correct: "B, D",
                explanation: "B: Create a VPC in a shared services account and share subnets via AWS RAM - Instead of creating a separate VPC for each team, create a single VPC in a shared services account and share needed subnets to other accounts using Resource Access Manager. Benefits: Centralized VPC → easier management, Less NAT Gateways, fewer VPNs → much cheaper.\n\nD: Use AWS Site-to-Site VPN for on-premises connectivity - Traffic < 50 Mbps → VPN is the cheapest option. No need for expensive Direct Connect or Transit Gateway. Simple and cost-effective, works well for low-throughput workloads."
            },
            {
                number: 216,
                text: "A solutions architect at a large company needs to set up network security for outbound traffic to the internet from all AWS accounts within an organization in AWS Organizations. The organization has more than 100 AWS accounts, and the accounts route to each other by using a centralized AWS Transit Gateway. Each account has an internet gateway and a NAT gateway for outbound traffic. The company deploys resources only in a single AWS Region. The company needs the ability to add centrally managed rule-based filtering on all outbound traffic to the internet for all AWS accounts in the organization. The peak load of outbound traffic will not exceed 25 Gbps per Availability Zone. Which solution meets these requirements?",
                options: [
                    "Create a new VPC for outbound traffic to the internet. Connect the existing transit gateway to the new VPC. Configure a new NAT gateway. Create an Auto Scaling group of Amazon EC2 instances that run an open-source internet proxy for rule-based filtering across all Availability Zones in the Region. Modify all default routes to point to the proxy's Auto Scaling group.",
                    "Create a new VPC for outbound traffic to the internet. Connect the existing transit gateway to the new VPC. Configure a new NAT gateway. Use an AWS Network Firewall firewall for rule-based filtering. Create Network Firewall endpoints in each Availability Zone. Modify all default routes to point to the Network Firewall endpoints.",
                    "Create an AWS Network Firewall firewall for rule-based filtering in each AWS account. Modify all default routes to point to the Network Firewall firewalls in each account.",
                    "In each AWS account, create an Auto Scaling group of network-optimized Amazon EC2 instances that run an open-source internet proxy for rule-based filtering. Modify all default routes to point to the proxy's Auto Scaling group."
                ],
                correct: "B",
                explanation: "AWS Network Firewall is designed for centralized, scalable, managed rule-based filtering. It's fully managed, handles tens of Gbps per AZ (meets the 25 Gbps requirement), and supports deep packet inspection, FQDN filtering, access control, and intrusion prevention. Centralized filtering is supported by deploying everything in a shared egress VPC. This provides the simplest multi-account governance model using Transit Gateway, Network Firewall endpoints, and NAT Gateway with centralized routing. No EC2 management required (No patches, No Auto Scaling, No failover logic, No maintenance of proxy instances)."
            },
            {
                number: 217,
                text: "A company uses a load balancer to distribute traffic to Amazon EC2 instances in a single Availability Zone. The company is concerned about security and wants a solutions architect to re-architect the solution to meet the following requirements: Inbound requests must be filtered for common vulnerability attacks, Rejected requests must be sent to a third-party auditing application, All resources should be highly available. Which solution meets these requirements?",
                options: [
                    "Configure a Multi-AZ Auto Scaling group using the application's AMI. Create an Application Load Balancer (ALB) and select the previously created Auto Scaling group as the target. Use Amazon Inspector to monitor traffic to the ALB and EC2 instances. Create a web ACL in WAF. Create an AWS WAF using the web ACL and ALB. Use an AWS Lambda function to frequently push the Inspector report to the third-party auditing application.",
                    "Configure an Application Load Balancer (ALB) and add the EC2 instances as targets. Create a web ACL in WAF. Create an AWS WAF using the web ACL and ALB name, and enable logging with Amazon CloudWatch Logs. Use a Lambda function to frequently push the logs to the third-party auditing application.",
                    "Configure an Application Load Balancer (ALB) along with a target group adding the EC2 instances as targets. Create an Amazon Kinesis Data Firehose with the destination of the third-party auditing application. Create a web ACL in WAF. Create an AWS WAF using the web ACL and ALB, then enable logging by selecting the Kinesis Data Firehose as the destination. Subscribe to AWS Managed Rules in AWS Marketplace, choosing the WAF as the subscriber.",
                    "Configure a Multi-AZ Auto Scaling group using the application's AMI. Create an Application Load Balancer (ALB) and select the previously created Auto Scaling group as the target. Create an Amazon Kinesis Data Firehose with a destination of the third-party auditing application. Create a web ACL in WAF. Create an AWS WAF using the web ACL and ALB, then enable logging by selecting the Kinesis Data Firehose as the destination. Subscribe to AWS Managed Rules in AWS Marketplace, choosing the WAF as the subscriber."
                ],
                correct: "D",
                explanation: "Option D meets all requirements:\n✓ Multi-AZ Auto Scaling group → High Availability\n✓ ALB → Load balancing and WAF integration\n✓ AWS WAF with Web ACL + Managed Rules → Protection from common attacks\n✓ Kinesis Data Firehose → Direct integration with 3rd-party audit system\n✓ WAF logging to Firehose → WAF rejected requests sent to auditing app\n\nFirehose is the only service that can forward logs to an external third-party directly, without custom code."
            },
            {
                number: 218,
                text: "A company is running an application in the AWS Cloud. The application consists of microservices that run on a fleet of Amazon EC2 instances in multiple Availability Zones behind an Application Load Balancer. The company recently added a new REST API that was implemented in Amazon API Gateway. Some of the older microservices that run on EC2 instances need to call this new API. The company does not want the API to be accessible from the public internet and does not want proprietary data to traverse the public internet. What should a solutions architect do to meet these requirements?",
                options: [
                    "Create an AWS Site-to-Site VPN connection between the VPC and the API Gateway. Use API Gateway to generate a unique API Key for each microservice. Configure the API methods to require the key.",
                    "Create an interface VPC endpoint for API Gateway, and set an endpoint policy to only allow access to the specific API. Add a resource policy to API Gateway to only allow access from the VPC endpoint. Change the API Gateway endpoint type to private.",
                    "Modify the API Gateway to use IAM authentication. Update the IAM policy for the IAM role assigned to the EC2 instances to allow access to API Gateway. Move the API Gateway into a new VPC. Deploy a transit gateway and connect the VPCs.",
                    "Create an accelerator in AWS Global Accelerator, and connect the accelerator to the API Gateway. Update the route table for all VPC subnets with a route to the Global Accelerator endpoint IP address. Add an API key for each service to use for authentication."
                ],
                correct: "B",
                explanation: "Solution steps:\n1. Create an Interface VPC Endpoint for API Gateway (PrivateLink) - Ensures traffic stays inside AWS network, provides a private IP inside your VPC for API Gateway, avoids the public internet entirely\n2. Restrict API access with endpoint policy - Only allow this specific API to be reachable, enforces least privilege\n3. Add API Gateway resource policy - Ensures API can only be invoked from the VPC endpoint, blocks ALL public internet access\n4. Change API Gateway endpoint type to Private - Makes the API reachable only through VPC endpoints, no public endpoint is created"
            },
            {
                number: 219,
                text: "A company has set up its entire infrastructure on AWS. The company uses Amazon EC2 instances to host its ecommerce website and uses Amazon S3 to store static data. Three engineers at the company handle cloud administration and development through one AWS account. Occasionally, an engineer alters an EC2 security group configuration of another engineer and causes noncompliance issues in the environment. A solutions architect must set up a system that tracks security group changes that the engineers make and must send alerts when the engineers make noncompliant changes to EC2 security settings. What is the FASTEST way for the solutions architect to meet these requirements?",
                options: [
                    "Set up AWS Organizations for the company. Apply SCPs to govern and track noncompliant security group changes that are made to the AWS account.",
                    "Enable AWS CloudTrail to capture the changes to EC2 security groups. Enable Amazon CloudWatch rules to provide alerts when noncompliant security settings are detected.",
                    "Enable SCPs on the AWS account to provide alerts when noncompliant security group changes are made to the environment.",
                    "Enable AWS Config on the EC2 security groups to track any noncompliant changes. Send the changes as alerts through an Amazon SNS topic."
                ],
                correct: "D",
                explanation: "Enable AWS Config + SNS Alerts. AWS Config provides: Out-of-the-box rules for security groups, Automatic configuration change tracking, Built-in compliance evaluation, Direct integration with SNS for alerts. This is the fastest solution as it requires minimal setup and provides immediate tracking and alerting capabilities."
            },
            {
                number: 220,
                text: "A company has IoT sensors that monitor traffic patterns throughout a large city. The company wants to read and collect data from the sensors and perform aggregations on the data. A solutions architect designs a solution in which the IoT devices are streaming to Amazon Kinesis Data Streams. Several applications are reading from the stream. However, several consumers are experiencing throttling and periodically encounter a ReadProvisionedThroughputExceeded error. Which actions should the solutions architect take to resolve this issue? (Choose three.)",
                options: [
                    "Reshard the stream to increase the number of shards in the stream.",
                    "Use the Kinesis Producer Library (KPL). Adjust the polling frequency.",
                    "Use consumers with the enhanced fan-out feature.",
                    "Reshard the stream to reduce the number of shards in the stream.",
                    "Use an error retry and exponential backoff mechanism in the consumer logic.",
                    "Configure the stream to use dynamic partitioning."
                ],
                correct: "A, C, E",
                explanation: "A - Increase the number of shards (Resharding Up): Increasing shards increases total read throughput, increases total parallelism, reduces consumer throttling, and allows more applications to read data simultaneously.\n\nC - Use Enhanced Fan-Out Consumers: Enhanced fan-out gives 2 MB/s dedicated throughput per consumer per shard, avoids shared throughput limits, eliminates consumers blocking each other, and removes most ReadProvisionedThroughputExceeded errors.\n\nE - Add retry + exponential backoff: Even with improved throughput, AWS recommends retries for throttled reads and backoff to ease contention. This prevents consumers from hammering the shard and increasing throttles."
            }
        ];

        function renderQuestions() {
            const container = document.getElementById('questionsContainer');
            
            questions.forEach((q, index) => {
                const card = document.createElement('div');
                card.className = 'question-card';
                card.id = `question-${index}`;
                
                let optionsHTML = '';
                q.options.forEach((option, optIndex) => {
                    const optionLetter = String.fromCharCode(65 + optIndex);
                    optionsHTML += `
                        <label class="option">
                            <input type="checkbox" name="q${index}" value="${optionLetter}">
                            <span class="option-text"><strong>${optionLetter}.</strong> ${option}</span>
                        </label>
                    `;
                });
                
                card.innerHTML = `
                    <div class="question-header">
                        <div class="question-number">Q${q.number}</div>
                        <div class="question-text">${q.text}</div>
                    </div>
                    <div class="options">
                        ${optionsHTML}
                    </div>
                    <div class="answer-section" id="answer-${index}">
                        <div class="correct-answer">✓ Correct Answer: ${q.correct}</div>
                        <div class="explanation">${q.explanation}</div>
                    </div>
                `;
                
                container.appendChild(card);
            });
        }

        function showAllAnswers() {
            questions.forEach((q, index) => {
                const answerSection = document.getElementById(`answer-${index}`);
                answerSection.classList.add('show');
            });
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        renderQuestions();
    </script>
</body>
</html>
