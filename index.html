<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AWS Exam Practice - Page 1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
            margin-bottom: 30px;
        }

        .header {
            background: linear-gradient(135deg, #232526 0%, #414345 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .page-info {
            font-size: 16px;
            opacity: 0.9;
            margin-top: 5px;
        }

        .content {
            padding: 30px;
        }

        .question-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 30px;
            border-left: 5px solid #667eea;
            transition: all 0.3s;
        }

        .question-card:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .question-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            gap: 15px;
        }

        .question-number {
            background: #667eea;
            color: white;
            padding: 8px 16px;
            border-radius: 50px;
            font-weight: bold;
            font-size: 16px;
            flex-shrink: 0;
        }

        .question-text {
            font-size: 16px;
            line-height: 1.7;
            color: #2d3748;
            font-weight: 500;
        }

        .options {
            margin: 20px 0;
        }

        .option {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: start;
        }

        .option:hover {
            border-color: #667eea;
            background: #f7fafc;
        }

        .option input[type="checkbox"] {
            margin-right: 12px;
            margin-top: 3px;
            cursor: pointer;
            width: 18px;
            height: 18px;
            flex-shrink: 0;
            accent-color: #667eea;
        }

        .option-text {
            flex: 1;
            line-height: 1.6;
            color: #4a5568;
            font-size: 15px;
        }

        .option-label {
            font-weight: bold;
            color: #667eea;
            margin-right: 6px;
        }

        .show-answer-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 15px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(16, 185, 129, 0.3);
        }

        .show-answer-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(16, 185, 129, 0.4);
        }

        .show-answer-btn.active {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
        }

        .answer-section {
            background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
            border: 2px solid #10b981;
            border-radius: 10px;
            padding: 20px;
            margin-top: 15px;
            display: none;
        }

        .answer-section.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .correct-answer {
            font-weight: bold;
            color: #065f46;
            margin-bottom: 15px;
            padding: 12px;
            background: white;
            border-radius: 6px;
            font-size: 16px;
            border-left: 4px solid #10b981;
        }

        .explanation-title {
            font-weight: bold;
            color: #065f46;
            margin-bottom: 10px;
            font-size: 15px;
        }

        .explanation {
            color: #1f2937;
            line-height: 1.7;
            white-space: pre-line;
            font-size: 14px;
        }

        .navigation {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 40px 30px;
            background: #f9fafb;
            border-top: 2px solid #e5e7eb;
        }

        .nav-btn {
            padding: 15px 40px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-btn.prev {
            background: #f3f4f6;
            color: #374151;
        }

        .nav-btn.next {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .nav-btn:hover:not(:disabled) {
            transform: translateY(-2px);
        }

        .nav-btn.next:hover {
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
        }

        @media (max-width: 768px) {
            .container {
                border-radius: 0;
            }

            .content {
                padding: 20px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 22px;
            }

            .question-card {
                padding: 20px;
            }

            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .navigation {
                flex-direction: column;
            }

            .nav-btn {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>AWS Solutions Architect Practice Exam</h1>
            <div class="page-info">Page 1 | Questions 211-220</div>
        </div>

        <div class="content" id="questionsContainer"></div>

        <div class="navigation">
            <button class="nav-btn prev" disabled>
                ‚Üê Previous Page
            </button>
            <button class="nav-btn next" onclick="nextPage()">
                Next Page (Questions 221-230) ‚Üí
            </button>
        </div>
    </div>

    <script>
        const questions = [
            {
                number: 211,
                text: "A company has 4,000 virtual machines running in a VMware vSphere/ESXi environment. The company wants to migrate to AWS, but they have: No CMDB, No performance monitoring tools, No detailed inventory, No visibility into utilization or idle resources. The company wants to estimate migration cost, identify underutilized VMs, and build an AWS migration plan with the least operational overhead. Which solution should a solutions architect recommend?",
                options: [
                    "Deploy the AWS Application Migration Service (MGN) agent on all VMs. Use Amazon Athena to analyze server performance. Export idle servers manually and exclude them from migration.",
                    "Use VMware tools to export VM data to CSV. Import the CSV into AWS Migration Hub. Perform manual analysis to identify underutilized workloads.",
                    "Deploy the agentless Migration Evaluator collector on the ESXi hosts. Allow it to gather performance and utilization data automatically. Review the reports in Migration Evaluator and export migration recommendations to AWS Migration Hub.",
                    "Use AWS Systems Manager to install CloudWatch agent on all VMs. Send performance metrics to CloudWatch. Build a server utilization dashboard in QuickSight and manually identify idle servers."
                ],
                correct: "C",
                explanation: "Migration Evaluator (formerly TSO Logic) provides:\n‚Ä¢ Agentless data collection from the ESXi hypervisor\n‚Ä¢ Automatic performance & utilization analysis\n‚Ä¢ Right-sizing recommendations\n‚Ä¢ Cost modeling for migration\n‚Ä¢ Import directly into AWS Migration Hub\n‚Ä¢ Zero need to touch each VM individually"
            },
            {
                number: 212,
                text: "A company runs a microservice as an AWS Lambda function. The microservice writes data to an on-premises SQL database that supports a limited number of concurrent connections. When too many Lambda invocations occur, the database crashes and causes downtime. The company has an AWS Direct Connect link and wants to protect the database from crashing. Which solution will meet these requirements?",
                options: [
                    "Write the data to an Amazon SQS queue. Configure the Lambda function to read from the queue and write to the existing database. Set a reserved concurrency limit on the Lambda function that is less than the number of connections the database supports.",
                    "Create a new Amazon Aurora Serverless DB cluster. Use AWS DataSync to migrate the data from the existing database to Aurora Serverless. Reconfigure the Lambda function to write to Aurora.",
                    "Create an Amazon RDS Proxy DB instance. Attach the RDS Proxy to the Amazon RDS DB instance. Reconfigure the Lambda function to write to the RDS Proxy.",
                    "Write the data to an Amazon SNS topic. Invoke the Lambda function to write to the database when the topic receives messages. Configure provisioned concurrency for the Lambda to match the database's supported connections."
                ],
                correct: "A",
                explanation: "Option A uses Amazon SQS as a buffer and Lambda reserved concurrency to throttle write operations.\n\nHow it solves the problem:\n‚Ä¢ SQS Queue stores incoming write requests and smooths traffic spikes\n‚Ä¢ Reserved Concurrency on Lambda limits concurrent executions to a safe number (e.g., if DB supports 5 connections, set concurrency = 5)\n‚Ä¢ Ensures the DB never receives more writes than it can handle\n‚Ä¢ No database migration needed - continues using the existing on-prem SQL database"
            },
            {
                number: 213,
                text: "A company uses a Grafana data visualization solution that runs on a single Amazon EC2 instance to monitor the health of the company's AWS workloads. The company has put extensive effort into building dashboards that must be preserved. Requirements: Dashboards must be highly available, Downtime cannot exceed 10 minutes, Company wants minimal ongoing maintenance, Grafana dashboards must be retained. Which solution meets these requirements with the LEAST operational overhead?",
                options: [
                    "Migrate to Amazon CloudWatch Dashboards. Recreate dashboards to match existing Grafana dashboards. Use automatic dashboards where possible.",
                    "Create an Amazon Managed Grafana workspace. Configure a new Amazon CloudWatch data source. Export dashboards from the existing Grafana instance. Import them into the Managed Grafana workspace.",
                    "Create an AMI with Grafana pre-installed. Store dashboards in Amazon EFS. Use an Auto Scaling group with ALB across two Availability Zones.",
                    "Configure AWS Backup to back up the EC2 instance hourly. Restore the EC2 from the newest snapshot in another Availability Zone when required."
                ],
                correct: "B",
                explanation: "Managed Grafana provides:\n‚Ä¢ No servers to maintain - Fully managed by AWS\n‚Ä¢ Automatic scaling and high availability\n‚Ä¢ No patching, no EC2, no ALB, no Auto Scaling groups\n‚Ä¢ Dashboards can be imported - Existing Grafana JSON dashboards can be exported and imported directly\n‚Ä¢ Downtime < 10 min - Quick cutover\n‚Ä¢ Meets all requirements: HA, preserves dashboards, minimal maintenance, AWS-native integrations"
            },
            {
                number: 214,
                text: "A company needs to migrate its customer transactions database from on premises to AWS. The database resides on an Oracle DB instance running on a Linux server. A new security requirement states that the company must rotate the database password every year. Which solution will meet these requirements with the LEAST operational overhead?",
                options: [
                    "Convert the database to Amazon DynamoDB using AWS Schema Conversion Tool (SCT). Store the password in AWS Systems Manager Parameter Store. Use an Amazon CloudWatch alarm to invoke a Lambda function for yearly password rotation.",
                    "Migrate the database to Amazon RDS for Oracle. Store the password in AWS Secrets Manager. Turn on automatic rotation. Configure a yearly rotation schedule.",
                    "Migrate the database to an Amazon EC2 instance. Use Systems Manager Parameter Store to store and rotate the connection string using Lambda on a yearly schedule.",
                    "Migrate the database to Amazon Neptune using AWS SCT. Configure CloudWatch to invoke a Lambda function for yearly password rotation."
                ],
                correct: "B",
                explanation: "Amazon RDS for Oracle with AWS Secrets Manager provides:\n‚Ä¢ Fully automated password rotation with minimal operational overhead\n‚Ä¢ Secrets Manager has built-in automatic rotation capabilities\n‚Ä¢ Seamless integration with RDS for Oracle\n‚Ä¢ No custom Lambda functions needed\n‚Ä¢ Simple yearly rotation schedule configuration"
            },
            {
                number: 215,
                text: "A solutions architect is designing an AWS account structure for a company that consists of multiple teams. All the teams will work in the same AWS Region. The company needs a VPC that is connected to the on-premises network. The company expects less than 50 Mbps of total traffic to and from the on-premises network. Which combination of steps will meet these requirements MOST cost-effectively? (Choose two.)",
                options: [
                    "Create an AWS CloudFormation template that provisions a VPC and the required subnets. Deploy the template to each AWS account.",
                    "Create an AWS CloudFormation template that provisions a VPC and the required subnets. Deploy the template to a shared services account. Share the subnets by using AWS Resource Access Manager.",
                    "Use AWS Transit Gateway along with an AWS Site-to-Site VPN for connectivity to the on-premises network. Share the transit gateway by using AWS Resource Access Manager.",
                    "Use AWS Site-to-Site VPN for connectivity to the on-premises network.",
                    "Use AWS Direct Connect for connectivity to the on-premises network."
                ],
                correct: "B, D",
                explanation: "B: Create a VPC in a shared services account and share subnets via AWS RAM\n‚Ä¢ Create a single VPC in a shared services account\n‚Ä¢ Share needed subnets to other accounts using Resource Access Manager\n‚Ä¢ Benefits: Centralized VPC ‚Üí easier management, Less NAT Gateways, fewer VPNs ‚Üí much cheaper\n\nD: Use AWS Site-to-Site VPN for on-premises connectivity\n‚Ä¢ Traffic < 50 Mbps ‚Üí VPN is the cheapest option\n‚Ä¢ No need for expensive Direct Connect or Transit Gateway\n‚Ä¢ Simple and cost-effective for low-throughput workloads"
            },
            {
                number: 216,
                text: "A solutions architect at a large company needs to set up network security for outbound traffic to the internet from all AWS accounts within an organization in AWS Organizations. The organization has more than 100 AWS accounts, and the accounts route to each other by using a centralized AWS Transit Gateway. Each account has an internet gateway and a NAT gateway for outbound traffic. The company deploys resources only in a single AWS Region. The company needs the ability to add centrally managed rule-based filtering on all outbound traffic to the internet for all AWS accounts in the organization. The peak load of outbound traffic will not exceed 25 Gbps per Availability Zone. Which solution meets these requirements?",
                options: [
                    "Create a new VPC for outbound traffic to the internet. Connect the existing transit gateway to the new VPC. Configure a new NAT gateway. Create an Auto Scaling group of Amazon EC2 instances that run an open-source internet proxy for rule-based filtering across all Availability Zones in the Region. Modify all default routes to point to the proxy's Auto Scaling group.",
                    "Create a new VPC for outbound traffic to the internet. Connect the existing transit gateway to the new VPC. Configure a new NAT gateway. Use an AWS Network Firewall firewall for rule-based filtering. Create Network Firewall endpoints in each Availability Zone. Modify all default routes to point to the Network Firewall endpoints.",
                    "Create an AWS Network Firewall firewall for rule-based filtering in each AWS account. Modify all default routes to point to the Network Firewall firewalls in each account.",
                    "In each AWS account, create an Auto Scaling group of network-optimized Amazon EC2 instances that run an open-source internet proxy for rule-based filtering. Modify all default routes to point to the proxy's Auto Scaling group."
                ],
                correct: "B",
                explanation: "AWS Network Firewall is designed for centralized, scalable, managed rule-based filtering:\n‚Ä¢ Fully managed service\n‚Ä¢ Handles tens of Gbps per AZ (meets the 25 Gbps requirement)\n‚Ä¢ Supports deep packet inspection, FQDN filtering, access control, intrusion prevention\n‚Ä¢ Centralized filtering in a shared egress VPC\n‚Ä¢ Simplest multi-account governance using Transit Gateway + Network Firewall endpoints\n‚Ä¢ No EC2 management (No patches, No Auto Scaling, No failover logic)"
            },
            {
                number: 217,
                text: "A company uses a load balancer to distribute traffic to Amazon EC2 instances in a single Availability Zone. The company is concerned about security and wants a solutions architect to re-architect the solution to meet the following requirements: Inbound requests must be filtered for common vulnerability attacks, Rejected requests must be sent to a third-party auditing application, All resources should be highly available. Which solution meets these requirements?",
                options: [
                    "Configure a Multi-AZ Auto Scaling group using the application's AMI. Create an Application Load Balancer (ALB) and select the previously created Auto Scaling group as the target. Use Amazon Inspector to monitor traffic to the ALB and EC2 instances. Create a web ACL in WAF. Create an AWS WAF using the web ACL and ALB. Use an AWS Lambda function to frequently push the Inspector report to the third-party auditing application.",
                    "Configure an Application Load Balancer (ALB) and add the EC2 instances as targets. Create a web ACL in WAF. Create an AWS WAF using the web ACL and ALB name, and enable logging with Amazon CloudWatch Logs. Use a Lambda function to frequently push the logs to the third-party auditing application.",
                    "Configure an Application Load Balancer (ALB) along with a target group adding the EC2 instances as targets. Create an Amazon Kinesis Data Firehose with the destination of the third-party auditing application. Create a web ACL in WAF. Create an AWS WAF using the web ACL and ALB, then enable logging by selecting the Kinesis Data Firehose as the destination. Subscribe to AWS Managed Rules in AWS Marketplace, choosing the WAF as the subscriber.",
                    "Configure a Multi-AZ Auto Scaling group using the application's AMI. Create an Application Load Balancer (ALB) and select the previously created Auto Scaling group as the target. Create an Amazon Kinesis Data Firehose with a destination of the third-party auditing application. Create a web ACL in WAF. Create an AWS WAF using the web ACL and ALB, then enable logging by selecting the Kinesis Data Firehose as the destination. Subscribe to AWS Managed Rules in AWS Marketplace, choosing the WAF as the subscriber."
                ],
                correct: "D",
                explanation: "Option D meets all requirements:\n‚úì Multi-AZ Auto Scaling group ‚Üí High Availability\n‚úì ALB ‚Üí Load balancing and WAF integration\n‚úì AWS WAF with Web ACL + Managed Rules ‚Üí Protection from common attacks\n‚úì Kinesis Data Firehose ‚Üí Direct integration with 3rd-party audit system (no custom code needed)\n‚úì WAF logging to Firehose ‚Üí Rejected requests sent to auditing app automatically"
            },
            {
                number: 218,
                text: "A company is running an application in the AWS Cloud. The application consists of microservices that run on a fleet of Amazon EC2 instances in multiple Availability Zones behind an Application Load Balancer. The company recently added a new REST API that was implemented in Amazon API Gateway. Some of the older microservices that run on EC2 instances need to call this new API. The company does not want the API to be accessible from the public internet and does not want proprietary data to traverse the public internet. What should a solutions architect do to meet these requirements?",
                options: [
                    "Create an AWS Site-to-Site VPN connection between the VPC and the API Gateway. Use API Gateway to generate a unique API Key for each microservice. Configure the API methods to require the key.",
                    "Create an interface VPC endpoint for API Gateway, and set an endpoint policy to only allow access to the specific API. Add a resource policy to API Gateway to only allow access from the VPC endpoint. Change the API Gateway endpoint type to private.",
                    "Modify the API Gateway to use IAM authentication. Update the IAM policy for the IAM role assigned to the EC2 instances to allow access to API Gateway. Move the API Gateway into a new VPC. Deploy a transit gateway and connect the VPCs.",
                    "Create an accelerator in AWS Global Accelerator, and connect the accelerator to the API Gateway. Update the route table for all VPC subnets with a route to the Global Accelerator endpoint IP address. Add an API key for each service to use for authentication."
                ],
                correct: "B",
                explanation: "Solution steps:\n1. Create an Interface VPC Endpoint for API Gateway (PrivateLink)\n   ‚Ä¢ Traffic stays inside AWS network\n   ‚Ä¢ Provides private IP inside your VPC\n   ‚Ä¢ Avoids public internet entirely\n\n2. Restrict API access with endpoint policy\n   ‚Ä¢ Only allow this specific API to be reachable\n   ‚Ä¢ Enforces least privilege\n\n3. Add API Gateway resource policy\n   ‚Ä¢ API can only be invoked from the VPC endpoint\n   ‚Ä¢ Blocks ALL public internet access\n\n4. Change API Gateway endpoint type to Private\n   ‚Ä¢ Reachable only through VPC endpoints"
            },
            {
                number: 219,
                text: "A company has set up its entire infrastructure on AWS. The company uses Amazon EC2 instances to host its ecommerce website and uses Amazon S3 to store static data. Three engineers at the company handle cloud administration and development through one AWS account. Occasionally, an engineer alters an EC2 security group configuration of another engineer and causes noncompliance issues in the environment. A solutions architect must set up a system that tracks security group changes that the engineers make and must send alerts when the engineers make noncompliant changes to EC2 security settings. What is the FASTEST way for the solutions architect to meet these requirements?",
                options: [
                    "Set up AWS Organizations for the company. Apply SCPs to govern and track noncompliant security group changes that are made to the AWS account.",
                    "Enable AWS CloudTrail to capture the changes to EC2 security groups. Enable Amazon CloudWatch rules to provide alerts when noncompliant security settings are detected.",
                    "Enable SCPs on the AWS account to provide alerts when noncompliant security group changes are made to the environment.",
                    "Enable AWS Config on the EC2 security groups to track any noncompliant changes. Send the changes as alerts through an Amazon SNS topic."
                ],
                correct: "D",
                explanation: "Enable AWS Config + SNS Alerts provides:\n‚Ä¢ Out-of-the-box rules for security groups\n‚Ä¢ Automatic configuration change tracking\n‚Ä¢ Built-in compliance evaluation\n‚Ä¢ Direct integration with SNS for alerts\n‚Ä¢ Fastest solution with minimal setup\n‚Ä¢ Immediate tracking and alerting capabilities\n\nThis is the quickest way to implement tracking and alerting for security group compliance."
            },
            {
                number: 220,
                text: "A company has IoT sensors that monitor traffic patterns throughout a large city. The company wants to read and collect data from the sensors and perform aggregations on the data. A solutions architect designs a solution in which the IoT devices are streaming to Amazon Kinesis Data Streams. Several applications are reading from the stream. However, several consumers are experiencing throttling and periodically encounter a ReadProvisionedThroughputExceeded error. Which actions should the solutions architect take to resolve this issue? (Choose three.)",
                options: [
                    "Reshard the stream to increase the number of shards in the stream.",
                    "Use the Kinesis Producer Library (KPL). Adjust the polling frequency.",
                    "Use consumers with the enhanced fan-out feature.",
                    "Reshard the stream to reduce the number of shards in the stream.",
                    "Use an error retry and exponential backoff mechanism in the consumer logic.",
                    "Configure the stream to use dynamic partitioning."
                ],
                correct: "A, C, E",
                explanation: "A - Increase the number of shards (Resharding Up):\n‚Ä¢ Increases total read throughput\n‚Ä¢ Increases total parallelism\n‚Ä¢ Reduces consumer throttling\n‚Ä¢ Allows more applications to read data simultaneously\n\nC - Use Enhanced Fan-Out Consumers:\n‚Ä¢ Gives 2 MB/s dedicated throughput per consumer per shard\n‚Ä¢ Avoids shared throughput limits\n‚Ä¢ Eliminates consumers blocking each other\n‚Ä¢ Removes most ReadProvisionedThroughputExceeded errors\n\nE - Add retry + exponential backoff:\n‚Ä¢ AWS recommends retries for throttled reads\n‚Ä¢ Backoff eases contention\n‚Ä¢ Prevents consumers from hammering the shard"
            }
        ];

        function renderQuestions() {
            const container = document.getElementById('questionsContainer');
            
            questions.forEach((q, index) => {
                const card = document.createElement('div');
                card.className = 'question-card';
                card.id = `question-${index}`;
                
                let optionsHTML = '';
                q.options.forEach((option, optIndex) => {
                    const optionLetter = String.fromCharCode(65 + optIndex);
                    optionsHTML += `
                        <label class="option">
                            <input type="checkbox" name="q${index}" value="${optionLetter}">
                            <span class="option-text">
                                <span class="option-label">${optionLetter}.</span>
                                ${option}
                            </span>
                        </label>
                    `;
                });
                
                card.innerHTML = `
                    <div class="question-header">
                        <div class="question-number">Q${q.number}</div>
                        <div class="question-text">${q.text}</div>
                    </div>
                    <div class="options">
                        ${optionsHTML}
                    </div>
                    <button class="show-answer-btn" onclick="toggleAnswer(${index})">
                        Show Answer & Explanation
                    </button>
                    <div class="answer-section" id="answer-${index}">
                        <div class="correct-answer">‚úì Correct Answer: ${q.correct}</div>
                        <div class="explanation-title">üìù Explanation:</div>
                        <div class="explanation">${q.explanation}</div>
                    </div>
                `;
                
                container.appendChild(card);
            });
        }

        function toggleAnswer(index) {
            const answerSection = document.getElementById(`answer-${index}`);
            const button = document.querySelectorAll('.show-answer-btn')[index];
            
            if (answerSection.classList.contains('show')) {
                answerSection.classList.remove('show');
                button.textContent = 'Show Answer & Explanation';
                button.classList.remove('active');
            } else {
                answerSection.classList.add('show');
                button.textContent = 'Hide Answer';
                button.classList.add('active');
                answerSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        function nextPage() {
            alert('Please provide the next 10 questions (221-230), and I will create Page 2 for you!');
            // In actual implementation: window.location.href = 'page-2.html';
        }

        renderQuestions();
    </script>
</body>
</html>
